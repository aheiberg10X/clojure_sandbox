(ns highlife.goant (:require [clojure.contrib.math :as math]
			     highlife.coords))



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; get local information
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(def NEIGHBOR-FUNC bounded-neighbor-coords)
(def COORD-TRANSLATOR no-translate)
(def DIM 10)

;just take the first occupier
(defn neighbor-whos [coord whowhere]
  (map #(first (get whowhere %)) (NEIGHBOR-FUNC coord DIM)))

(defn neighbor-whats [coord whatwhere]
  (map #(get whatwhere %) (NEIGHBOR-FUNC coord DIM)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; initial conditions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defn make-whatwhere [dim]
  (let [grid-coords (for [x (range dim) y (range dim)] [x y])]
    (reduce (fn [acc new] (assoc acc new (ref 0))) {} grid-coords)))

(defn make-whatwhere-with-target [target dim]
  (let [max-distance (distance-between [0 0] [dim dim])
        grid-coords (for [x (range dim) y (range dim)] [x y])]
    (reduce (fn [whatwhere coord]
              (assoc whatwhere
                     coord
                     (ref (- max-distance (distance-between target coord)))))
            {}
            grid-coords)))

;(def whatwhere (make-whatwhere-with-target [7 5] DIM))
(def whatwhere (make-whatwhere DIM))
;(def whowhere {[1 1] [(ref "loner")] [5 6] [(ref "a friend!")]})
(def whowhere {[5 6] "the dude"})



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; update the self
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defn get-married [self]
  (dosync (ref-set self "married!")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;   move primitives
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defn move [oldcoord newcoord whowhere]
  (let [self (get whowhere oldcoord)
	translated (COORD-TRANSLATOR newcoord DIM)]
    (if (and (coord-in-bounds? translated DIM) (not (= oldcoord translated)))
      (assoc (dissoc whowhere oldcoord)
             translated
             (concat self (get whowhere translated)))
      whowhere)))

(defn no-move [coord whowhere] whowhere)

(def moves
  (map (fn [func] (fn [coord whowhere] (move coord (func coord) whowhere)))
       (neighbor-func-seq)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;   complex moves
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defn which-side [point partition]
  (if (= point partition) 0 (if (< point partition) -1 1)))

(defn which-quadrant [coord target]
  (let [[x y] coord
	[a b] target
	xside (which-side x a)
	yside (which-side y b)]
    [xside yside]))

(def quadrant-move-map
     (apply hash-map (interleave [[1 1]  [1 0]  [1 -1]
                                  [0 1]  [0 0]  [0 -1]
                                  [-1 1] [-1 0] [-1 -1]] moves)))

(defn move-to-target [target coord whowhere]
  (let [quadrant (which-quadrant coord target)]
    ((get quadrant-move-map quadrant) coord whowhere)))
    
(defn random-move [coord whowhere]
  ((rand-nth moves) coord whowhere))

(defn make-distribution [percents]
  (if (not (= 100 (apply + percents)))
    (println "Error: percents don't add up to 100.")
    (if (not (= 9 (count percents)))
      (println "Error. Distribution needs 9 buckets.")
      (loop [dist []
             left 0
             percs percents]
        (let [perc (first percs)
              right (+ left perc)
              tail (rest percs)]
          (if (empty? tail)
            (conj dist [left right])
            (recur (conj dist [left right]) right tail)))))))

(def move-down-dist (make-distribution [0 0 0 0 0 50 0 50 0]))
(defn random-dist []
  (let [eight-rands (take 8 (repeatedly #(int (rand 100))))
        eight-sum ()]
    ))

(defn move-from-distribution [distribution coord whowhere]
  (loop [ix 0
         dist distribution
         random (rand 100)]
    (let [[l r] (first dist)
          tail (rest dist)]
      (if (and (>= random l) (< random r))
        ((nth moves ix) coord whowhere)
        (if (empty? tail)
          (println "distribution is messed, random not found in any interval")
          (recur (inc ix) tail random))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;   actions --- deterraform!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defn no-action [coord])

(defn lay-pheremone [coord]
  (dosync (alter (get whatwhere coord) + 10)))

(defn mark-explored [coord]
  (dosync (alter (get whatwhere coord) + 1)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;   moveactions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;move directly to a target
(defn move-to-44 [self neighbors]
  [(partial move-to-target [4 4]) no-action])

;randomly pick a direction to move until you have found at least one neighbor
(defn find-someone [myself mytile neighbors tiles]
  (let [num-neighbors (reduce (fn [sum n] (+ sum (if n 1 0))) 0 neighbors)]
    (println "findsomeone" num-neighbors)
    (if (<= num-neighbors 1)
      ;(partial move-from-distribution move-down-dist)
      [random-move mark-explored] 
      [no-move no-action])))

;(defn directed-wander [self neighbors])

(defn get-number [tile-ref]
  (if tile-ref @tile-ref -1))

(defn most-attractive-tile [tile-scoring-func tiles]
  (reduce (fn [acc new]
            (let [[maxix maxv curix] acc
                  newv (tile-scoring-func new)]                    
              (if (> newv maxv)
                [curix newv (inc curix)]
                [maxix maxv (inc curix)])))
          [0 0 0]
          tiles))

(defn follow-your-nose [myself mytile neighbors tiles]
  (let [mytile-sexiness @mytile
        [ix sexiness whocare] (most-attractive-tile get-number tiles)]
    (if (> mytile-sexiness sexiness)
      [no-move no-action]
      [(nth moves ix) lay-pheremone])))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; make things happen
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;has whatwhere side-effects
(defn get-moves-do-actions [whowhere]
  (println "calling get-actions")
  (map (fn [keyvalue]
         (let [[coord who] keyvalue
	       thiswhat (get whatwhere coord)
	       neighbors (neighbor-whos coord whowhere)
	       tiles (neighbor-whats coord whatwhere)
               [move action] (find-someone who thiswhat neighbors tiles)]
           (action coord)
           (partial move coord)))
       whowhere))

(defn apply-actions [whowhere]
  (reduce (fn [new-ww move] (move new-ww))
          whowhere
          (get-moves-do-actions whowhere)))

(defn step [num]
  (loop [ww whowhere
         gen num]
    (println gen)
    (if (= 0 gen)
      (def whowhere ww)
      (recur (apply-actions ww) (dec gen)))))





	
